#!/usr/bin/env python

import _mysql
import sys
import os
import textwrap
import smtplib
from email.mime.text import MIMEText
from email.utils import formatdate
from datetime import date, timedelta
import localconfig
import csv
from collections import defaultdict
import math
import argparse
import re
import json
from packaging import version

sys.path.append(os.path.join(localconfig.brbase, "utils"))
import getdeveloperlib  # noqa: E402

RE_DATE = re.compile(r'^\d\d\d\d-\d\d-\d\d$')
RE_HASH_40 = re.compile(r'.*[a-fA-F0-9]{40}.*')

baseurl = "autobuild.buildroot.net"
http_baseurl = "http://" + baseurl

developers = getdeveloperlib.parse_developers(localconfig.brbase)


def get_branches():
    """Returns the list of branches currently tested by the autobuilders."""
    branch_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), "..", "web", "branches")
    with open(branch_file) as r:
        csv_branches = r.readlines()
    branches = []
    for branch in csv.reader(csv_branches):
        branches.append(branch[0])
    return branches


def get_overall_stats(db, datestr, branches):
    '''
    Find, for the previous day, the global statistics: number of
    success, failures, timeouts, and total number of builds.
    '''
    stats = {}
    for branch in branches:
        db.query("""select status,count(id) as count from results
        where date(builddate) = '{}' and branch = '{}' group by status""".format(datestr, branch))
        r = db.use_result()
        result = dict(r.fetch_row(maxrows=0))
        if '0' in result:
            success = int(result['0'])
        else:
            success = 0
        if '1' in result:
            failures = int(result['1'])
        else:
            failures = 0
        if '2' in result:
            timeouts = int(result['2'])
        else:
            timeouts = 0
        total = success + failures + timeouts
        stats[branch] = (success, failures, timeouts, total)
    return stats


class Notification:
    def __init__(self):
        self.arch_notifications = defaultdict(list)
        self.package_notifications = defaultdict(list)


def get_mklist(basepath):
    '''
    Calculate the list of .mk files in the Buildroot source tree, will
    be used to guess the name of the packages that caused build
    failures.
    '''
    mklist = []
    for root, dirs, files in os.walk(basepath):
        for f in files:
            if not f.endswith(".mk"):
                continue
            mklist.append(os.path.splitext(f)[0])
    return mklist


mklist = get_mklist(localconfig.brbase)


def add_arch_notification(branch, notifications, build_result):
    '''
    Add to the notifications{} dict notifications that are related to
    architecture "maintainers".
    '''
    arch = build_result['arch']
    for dev in developers:
        if arch not in dev.architectures:
            continue
        n = notifications.setdefault(dev, Notification())
        n.arch_notifications[branch].append(build_result)


def find_package(reason):
    '''
    Given a failure reason as provided by the autobuilders, tries to
    find the corresponding package by stripping progressively the last
    "-<something>" parts of the failure reason. A failure reason like
    "qt5location-5.6.1-1" will first attempt to find a package named
    "qt5location-5.6.1" (which will not find any match) and then attempt
    to find a package named "qt5location" (which will match an existing
    package).
    '''
    if reason == "unknown":
        return
    # Strip host- prefix so that host packages can match
    if reason.startswith("host-"):
        reason = reason[5:]
    # Strip a first component of the version
    while "-" in reason:
        reason = reason[:reason.rindex("-")]
        if reason in mklist:
            return reason
    return None


ORPHAN_DEVELOPER = "Arnout Vandecappelle <arnout@mind.be>"


def get_orphan_developer():
    for dev in developers:
        if dev.name == ORPHAN_DEVELOPER:
            return dev
    return None


def add_package_notification(branch, notifications, build_result):
    '''
    Add to the notifications{} dict notifications that are related to
    package "maintainers".
    '''
    pkg = find_package(build_result['reason'])
    if not pkg:
        return
    orphan = True
    for dev in developers:
        if pkg not in dev.packages:
            continue
        orphan = False
        n = notifications.setdefault(dev, Notification())
        n.package_notifications[branch].append(build_result)
    if orphan:
        dev = get_orphan_developer()
        n = notifications.setdefault(dev, Notification())
        n.package_notifications[branch].append(build_result)
    build_result['orphan'] = orphan


def shrink_str(string, length, align='right', fill='...'):
    '''
    Returns the `string` shrinked to fit `length` characters and with `fill`
    added on `align`.

    :Example:

    >>> shrink_str('This is a very long string!', 10)
    'This is...'

    >>> shrink_str('This is a very long string!', 20, align='center', fill='[...]')
    'This is[...] string!'
    '''
    if len(fill) > length:
        raise ValueError('`length` cannot be shorter than `fill`')
    if align == 'right':
        return string[:length-len(fill)] + fill if len(string) > length else string
    elif align == 'left':
        return fill + string[len(string)-length+len(fill):] if len(string) > length else string
    elif align == 'center':
        lcut = math.floor((length - len(fill)) / 2)
        rcut = len(string) - math.ceil((length - len(fill)) / 2)
        return string[:lcut] + fill + string[rcut:] if len(string) > length else string
    else:
        raise ValueError('align must be either `left`, `right` or `center`')


def show_results(results, show_status, show_orphan=False):
    contents = ""
    # Header
    if show_status:
        contents += '{:^12} | {:^30} | {:^3} | {:^79}'.format('arch', 'reason', 'OK?', 'url')
    else:
        contents += '{:^12} | {:^30} | {:^79}'.format('arch', 'reason', 'url')
    if show_orphan:
        contents += ' | {:^5}'.format('orph?')

    if show_status:
        contents += '\n{0:-^12}-+-{0:-^30}-+-{0:-^3}-+-{0:-^79}-'.format('')
    else:
        contents += '\n{0:-^12}-+-{0:-^30}-+-{0:-^79}-'.format('')
    if show_orphan:
        contents += '+-{0:-^5}-'.format('')
    contents += '\n'

    # Actual data
    for r in results:
        arch = r['arch']
        reason = shrink_str(r['reason'], 30)
        status = int(r['status'])
        if status == 1:
            status_str = "NOK"
        elif status == 2:
            status_str = "TIM"
        orphan_str = 'ORPH' if r.get('orphan') else ''
        url = http_baseurl + "/results/" + r['identifier']
        if show_status:
            contents += "{:^12} | {:^30} | {:^3} | {:^79}".format(arch, reason, status_str, url)
        else:
            contents += "{:^12} | {:^30} | {:^79}".format(arch, reason, url)
        if show_orphan:
            contents += " | {:^4}\n".format(orphan_str)
        else:
            contents += "\n"
    return contents


def developers_email(smtp, branches, notifications, datestr, dry_run):
    '''
    Send the e-mails to the individual developers
    '''
    for dev, notif in notifications.iteritems():
        to = dev.name
        email_from = localconfig.fromaddr
        subject = "[{}] Your daily results for {}".format(baseurl, datestr)
        contents = "Hello,\n\n"
        contents += textwrap.fill("This is the list of Buildroot build failures that occurred on {}, "
                                  "and for which you are a registered architecture developer or package "
                                  "developer. Please help us improving the quality of Buildroot by "
                                  "investigating those build failures and sending patches to fix them. "
                                  "Thanks!".format(datestr))
        contents += "\n\n"
        show_orphan = dev.name == ORPHAN_DEVELOPER

        for branch in branches:
            archs = notif.arch_notifications.get(branch, [])
            packages = notif.package_notifications.get(branch, [])

            if len(archs) == 0 and len(packages) == 0:
                continue

            contents += "Results for the '{}' branch\n".format(branch)
            contents += "=========================" + "=" * len(branch) + "\n\n"

            if len(archs) != 0:
                contents += "Build failures related to your architectures:\n\n"
                contents += show_results(archs, show_status=False, show_orphan=False)
                contents += "\n\n"
            if len(packages) != 0:
                contents += "Build failures related to your packages:\n\n"
                contents += show_results(packages, show_status=False, show_orphan=show_orphan)

            contents += "\n"

        contents += "-- \n"
        contents += http_baseurl
        if dry_run:
            print "====================================================="
            print "To: {}".format(to)
            print "From: {}".format(email_from)
            print "Subject: {}".format(subject)
            print
            print contents
            print "====================================================="
        else:
            msg = MIMEText(contents)
            msg['Subject'] = subject
            msg['To'] = to
            msg['From'] = email_from
            msg['Date'] = formatdate()
            smtp.sendmail(email_from, to, msg.as_string())
            print "To: {}".format(dev.name)


def global_email_branch_result(results, results_by_reason, branch):
    contents = "Results for branch '{}'\n".format(branch)
    contents += "=====================" + "=" * len(branch) + "\n\n"
    contents += "Classification of failures by reason\n"
    contents += "------------------------------------\n\n"
    for r in results_by_reason:
        reason = shrink_str(r['reason'], 30)
        count = int(r['reason_count'])
        contents += "{:>30} | {:<2}\n".format(reason, count)
    contents += "\n\n"
    contents += "Detail of failures\n"
    contents += "------------------\n\n"
    contents += show_results(results, show_status=True, show_orphan=True)
    contents += "\n"
    return contents


def global_email(smtp, results, results_by_reason, datestr, overall, dry_run):
    '''
    Send the global e-mail to the mailing list
    '''
    to = "buildroot@buildroot.org"
    email_from = localconfig.fromaddr
    subject = "[{}] Daily results for {}".format(baseurl, datestr)
    contents = "Hello,\n\n"
    if len(overall) != 0:
        contents += "Autobuild statistics for {}\n".format(datestr)
        contents += "===============================\n\n"
        contents += "      branch |  OK | NOK | TIM | TOT |\n"
    for branch in sorted(overall.iterkeys()):
        stats = overall[branch]
        if stats[3] == 0:
            continue
        contents += "  {:^10} | {:^3} | {:^3} | {:^3} | {:^3} |\n".format(branch, stats[0], stats[1], stats[2], stats[3])
    contents += "\n"
    for branch in results.keys():
        if len(results[branch]) == 0:
            continue
        contents += global_email_branch_result(results[branch], results_by_reason[branch], branch)
    contents += "\n"
    contents += "-- \n"
    contents += http_baseurl
    if dry_run:
        print "====================================================="
        print "To: {}".format(to)
        print "From: {}".format(email_from)
        print "Subject: {}".format(subject)
        print
        print contents
        print "====================================================="
    else:
        msg = MIMEText(contents)
        msg['Subject'] = subject
        msg['To'] = to
        msg['From'] = email_from
        msg['Date'] = formatdate()
        smtp.sendmail(email_from, [to], msg.as_string())
        print "To: buildroot@buildroot.net"


def get_build_results(db, datestr, branches):
    '''
    Get the list of build failures for the past day
    '''
    results = {}
    for branch in branches:
        db.query("""select * from results
        where date(builddate) = '{}'
        and status != 0 and branch = '{}'
        order by reason""".format(datestr, branch))
        r = db.use_result()
        results[branch] = r.fetch_row(how=1, maxrows=0)
    return results


def get_build_results_grouped_by_reason(db, datestr, branches):
    results_by_reason = {}
    for branch in branches:
        db.query("""select reason,count(id) as reason_count from results
        where date(builddate) = '{}' and status != 0 and branch = '{}'
        group by reason order by reason_count desc, reason""".format(datestr, branch))
        r = db.use_result()
        results_by_reason[branch] = r.fetch_row(how=1, maxrows=0)
    return results_by_reason


def get_outdated_pkgs(path):
    with open(path, 'r') as f:
        stats = json.load(f)
    s = []
    for name, pkg in stats['packages'].items():
        status, latest_ver, p_id = pkg['latest_version']
        cur_ver = pkg['current_version']
        # if not upstream version was found, skip
        if status not in (2, 3):
            continue
        # if there's no current or no latest version to compare, skip
        if not cur_ver or not latest_ver:
            continue
        # if the current version is a Git hash, skip as
        # release-monitoring.org only knows about "regular" releases
        if RE_HASH_40.match(cur_ver):
            continue
        # if the current version in Buildroot is newer or equal to the
        # latest reported by release-monitoring, skip
        if version.parse(str(cur_ver)) >= version.parse(str(latest_ver)):
            continue

        s.append({'name': str(name),
                  'id': p_id,
                  'version': str(cur_ver),
                  'upstream': str(latest_ver),
                  'from': 'DISTRO' if status == 2 else 'GUESS'})
    return sorted(s, key=lambda pkg: pkg['name'])


def calculate_notifications(results):
    '''
    Prepare the notifications{} dict for the notifications to individual
    developers, based on architecture developers, package developers,
    defconfig developers and runtime developers.
    '''
    notifications = {}
    for branch in results.keys():
        for result in results[branch]:
            status = int(result['status'])
            if status != 1:
                continue
            add_arch_notification(branch, notifications, result)
            add_package_notification(branch, notifications, result)
    return notifications


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--dry-run', action='store_true', help='Do not send email, only show output')
    parser.add_argument('--date', action='store', help='Use this date instead of yesterday')
    parser.add_argument('--branches', action='store', nargs='+', help='List of branches (blank separated)')
    parser.add_argument('--dest', action='store', nargs='+', choices=['dev', 'global'],
                        help='List of emails type to send (ie. global, dev)')
    parser.add_argument('--data', action='store', nargs='+', choices=['autobuild'],
                        help='List of information to add in emails (blank separated)')
    args = parser.parse_args()
    if args.date and not RE_DATE.match(args.date):
        parser.error('date must be in format YYYY-MM-DD')
    return args


def __main__():
    args = parse_args()
    if args.date:
        date_str = args.date
    else:
        yesterday = date.today() - timedelta(1)
        date_str = yesterday.strftime('%Y-%m-%d')
    branches = args.branches if args.branches else get_branches()
    email_dest = set(args.dest) if args.dest else {'dev', 'global'}
    email_data = set(args.data) if args.data else {'autobuild'}

    db = _mysql.connect(host=localconfig.host,
                        user=localconfig.user,
                        passwd=localconfig.passwd,
                        db=localconfig.db)
    if 'autobuild' in email_data:
        overall_stats = get_overall_stats(db, date_str, branches)
        results = get_build_results(db, date_str, branches)
        results_by_reason = get_build_results_grouped_by_reason(db, date_str, branches)
    else:
        overall_stats = {}
        results = {}
        results_by_reason = {}
    notifications = calculate_notifications(results)
    smtp = smtplib.SMTP(localconfig.smtphost, localconfig.smtpport)
    smtp.starttls()
    smtp.login(localconfig.smtpuser, localconfig.smtppass)
    if 'dev' in email_dest:
        developers_email(smtp, branches, notifications, date_str, args.dry_run)
    if 'global' in email_dest:
        global_email(smtp, results, results_by_reason, date_str,
                     overall_stats, args.dry_run)
    smtp.quit()


__main__()
